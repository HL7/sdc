<div xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://hl7.org/fhir ../../input-cache/schemas/R4/fhir-single.xsd">
  <p>
    Questionnaires are excellent tools for data capture.  They allow tight control over what data is gathered and ensure information is gathered consistently
    across multiple users.  However, data gathered using different questionnaires - or even different versions of the same questionnaire - is often not
    comparable.  It is also not very searchable or easily integrated with discrete data sources.  Because of this, the general recommendation in FHIR is to
    use questionnaires for raw data capture but then to convert the resulting QuestionnaireResponse instances into other FHIR resources - Observations,
    MedicationStatements, FamilyMemberHistories, etc.  This allows the data gathered to then be easily combined with other data into FHIR documents and
    messages and exposed over FHIR REST interfaces.
  </p>
  <p>
    Such conversion can be done with custom code written on a Questionnaire by Questionnaire basis.  However, it makes the process much easier if it's possible
    to write generic software that can convert any arbitrary QuestionnaireResponse into appropriate FHIR resources leveraging metadata embedded in the
    Questionnaire.  This portion of the SDC guide defines mechanisms for doing so.
  </p>

  <a name="caveats"> </a>
  <h3>Caveats, considerations and rules with form data extraction</h3>
  <ul>
    <li>
      Extraction is a step that only makes sense to occur once a QuestionnaireResponse is completed.  Prior to that, the information to create valid resource
      instances may not be available and conversion logic is likely to fail.  The types of data produced will vary by Questionnaire.</li>
    <li>
      Some questionnaires might result in a single resource.  Others will produce a Bundle of resources.  In some cases, the result might be a transaction
      intended to create some resources and update others.</li>
    <li>
      If the Questionnaire is being designed with conversion to a resource in mind, conversion will be a straight-forward process because the questions
      will align well with how FHIR stores data - and the questions can even be tuned to align with particular profiles around the use of terminology, which
      elements are mandatory, etc.  However, if converting data from questionnaires designed without FHIR in mind, mapping may be more challenging.  Required
      elements may need to be inferred, codes may need to be transformed and other transformations may be necessary to ensure that converted data meets
      expectations for use, such as aligning with country-specific implementation guides.  In some cases, alignment may not be possible.</li>
    <li>
      Once a QuestionnaireResponse has been converted, it might not be necessary to retain the QuestionnaireResponse any longer, as all data access and
      subsequent maintenance will occur through the 'traditional' resources.  However, in many environments, the QuestionnaireResponse will be retained anyhow
      to keep a record of the original source-of-truth and for traceability reasons.</li>
    <li>
      As with population, 'extraction' can happen in one of two ways: The <a href="CapabilityStatement-sdc-form-filler.html">SDC Form Filler</a> can invoke the
      <a href="OperationDefinition-QuestionnaireResponse-extract.html">$extract</a> operation on a <a href="CapabilityStatement-sdc-form-manager.html">SDC Form Manager</a> 
      to generate the resource or Bundle containing the information expressed in the QuestionnaireResponse.
      Alternatively, the <a href="CapabilityStatement-sdc-form-filler.html">SDC Form Filler</a> can perform the extraction process locally without relying
      on an external process.  Some Form Fillers might rely on the operation approach for certain extraction techniques and perform others internally.</li>
    <li>
      When resources have been generated from a QuestionnaireResponse, the <a href="{{site.data.fhir.path}}provenance.html">Provenance</a> instance associated
      with the creation of the resource instance(s) can and SHOULD include an <code>entity</code> reference of type 'source' that points back to the original
      QuestionnaireResponse.  If Observations are generated, they can also have an explicit <code>derivedFrom</code> link pointing back to the
      QuestionnaireResponse.</li>
    <li>
      In theory, it is possible to use Questionnaire as a user-facing interface to allow maintenance of one or more resources.  The source data can be used to
      <a href="populate.html">populate</a> the QuestionnaireResponse and once the response is 'submitted', the data can then be extracted and used to update
      the existing resources.  For this to work, the <code>id</code> of the resource must be retained through the round-trip process to allow for the update,
      and is only safe if every single data element in the existing resource instance (including extensions) is going to be correctly populated by the Questionnaire.
      Otherwise, the process will delete any data not present in the QuestionnaireResponse - including data that may not even have been renderable via the Questionnaire.<br/>
      Updates can be supported by storing the id as a <a href="{{site.data.fhir.ver.ext}}/StructureDefinition-questionnaire-hidden.html">hidden</a> question not shown to the
      user.  This question item would have a type of 'string' and, if using the definition-based extraction approach, a definition that corresponded to the 
      'id' element of the relevant resource type (e.g. <code>http://hl7.org/fhir/StructureDefinition/AllergyIntolerance#AllergyIntolerance.id</code>).     
      Note that the inclusion of the id as a hidden question is only relevant for the definition-based and StructureMap-based approaches. It is not needed
      for the Observation-based approach.</li>
    <li>
      Sometimes the author interested in making a Questionnaire "extractable" does not have authority to make changes to the "official" Questionnaire.  In other
      cases, there might be one official Questionnaire, but a need to create extracted resources that comply with different sets of profiles - and thus a need
      for different metadata in the Questionnaire to support the extraction process.  In this case, rather than basing the extraction on the original
      Questionnaire, it can be based on a derived Questionnaire - one that has a <code>Questionnaire.derivedFrom</code> relationship to the same canonical URL
      the QuestionnaireResponse refers to.  The derived Questionnaire would contain the same content as the base Questionnaire, but would have additional
      extensions inserted to support data extraction.</li>
    <li>
      When capturing quantities, it's common for questionnaires to prompt for the numeric value and to note the 'fixed' unit as part of the question.  For
      example, "Please specify the patient's weight in kilograms".  When extracting the value for representation in a resource, a unit will be added.
      The <a href="{{site.data.fhir.ver.ext}}/StructureDefinition-questionnaire-unit.html">questionnaire-unit</a> extension SHOULD be included on the question to support
      the extraction process.</li>
    <li>
      When performing extraction, the considerations around <a href="expressions.html#expressionerrors">errors and lack of support</a> for expressions may come into
      play.  In addition, similar considerations can also be relevant in terms of what 'extraction' approach the Questionnaire supports, as opposed to what
      level of extraction capability the Form Filler has.  The desired behavior of alerting the user that extraction won't be possible is the same whether the issue 
      is "handles FHIRPath vs. CQL" or "uses Observation-based vs. definition-based".</li>
    <li>
      When generating or updating resources based on information in a QuestionnaireResponse, there may be a desire to capture where that information was
      sourced from, what software was used to perform conversion, etc.  The way to represent this information in FHIR is using the
      <a href="{{site.data.fhir.path}}provenance.html">Provenance</a> resource.  The QuestionnaireResponse would be referenced using
      <code>Provenance.entity.what</code> where the <code>Provenance.entity.role</code> would be 'source'.  Software information would be captured in
      <code>Provenance.agent</code>.  If the produced records are Observations, the resulting Observation(s) can also directly point to the
      QuestionnaireResponse using <code>Observation.derivedFrom</code>.</li>
    <li>A single Questionnaire can sometimes include data from multiple subjects.  The extraction process needs to be aware of what the subject
      for a given section of the Questionnaire is and take that into account when creating resources based on the QuestionnaireResponse.  (E.g. don't 
      create a heart-rate observation on the mother if that part of the  Questionnaire is capturing information about their child.
      In SDC, the fact that a particular 'group' in a Questionnaire has
      a distinct subject is communicated using the <a href="StructureDefinition-sdc-questionnaire-isSubject.html">isSubject</a> extension.  An 
      <a href="StructureDefinition-sdc-questionnaireresponse-isSubject.html">equivalent extension</a> flags the element within the 
      QuestionnaireResponse.</li>
    <li>When selecting data for extraction, systems must always check for the presence of modifier elements or other elements (e.g. Quantity.comparator) 
    that may shift the meaning of the data elements selected and ensure that records whose meaning might be atypical are either not used for extraction 
    or are appropriately flagged to the user for review and possible adjustment.</li>
  </ul>
  <a name="service"> </a>
  <h3>Extraction service</h3>
  <p>
    Like <a href="populate.html">Questionnaire population</a>, extracting data from a QuestionnaireResponse is a complex process involving querying existing
    FHIR data and using more advanced technologies such as FHIRPath and StructureMap.  It's therefore a function that systems may also wish to offload to a
    separate system.  The <a href="OperationDefinition-QuestionnaireResponse-extract.html">QuestionnaireResponse extract</a> has been created for this purpose.  It takes in a
    completed QuestionnaireResponse and returns either an individual FHIR resource or a Bundle of resources, depending on the type of Questionnaire.  The
    operation does not post the created resources to a server.  It's up to the client system to determine what action(s) to take with the created
    content.
  </p>
  <p>
    NOTE: It's the responsibility of the client system to ensure that any generated resources are valid against necessary profiles, etc. before using content
    produced by this operation.
  </p>
  <a name="design"> </a>
  <h3>Designing Questionnaires to support data extraction</h3>
  <p>
    This specification defines four different mechanisms to embed information in Questionnaires to support subsequent resource extraction:
  </p>
  <ul>
    <li>
      <a href="#obs-extract">Observation-based</a>
    </li>
    <li>
      <a href="#definition-extract">Definition-based</a>
    </li>
    <li>
      <a href="#template-extract">Template-based</a>
    </li>
    <li>
      <a href="#map-extract">StructureMap-based</a>
    </li>
  </ul>
  <p>
    Systems are free to experiment with other extraction mechanisms but cannot expect support for those from other SDC-conformant systems.
  </p>
  <p>
    Each mechanism has its own profile that includes the additional resource elements or extensions relevant for supporting a particular mechanism: <a href="StructureDefinition-sdc-questionnaire-extr-obsn.html">SDC Questionnaire Extract - Observation</a>, 
    <a href="StructureDefinition-sdc-questionnaire-extr-defn.html">SDC Questionnaire Extract - Definition</a>, <a href="StructureDefinition-sdc-questionnaire-extr-template.html">SDC Questionnaire Extract - Template</a>, 
    and <a href="StructureDefinition-sdc-questionnaire-extr-smap.html">SDC Questionnaire Extract - Structure Map</a> profiles.<br/>
    Each profile identifies 
    specific 'must support' elements and extensions that systems that claim to support a specific SDC extraction mechanism <code>SHALL</code> be capable of extracting data, as befits the CapabilityStatement(s) 
    they claim conformance to. Each system should choose which approach(es) it wishes to use and support based on the elements specified in that profile.
  </p>
  <p>
    Some of these mechanisms make use of FHIR-based queries, FHIRPath and/or CQL as well as extensions that include expressions in one of these languages.
    Implementers should read the <a href="expressions.html">Using Expressions</a> page for background and guidance on these technologies and extensions.
  </p>
  <a name="obs-extract"> </a>
  <h4>Observation-based extraction</h4>
  <table class="grid">
    <tbody>
      <tr>
        <th>Profile:</th>
        <td><a href="StructureDefinition-sdc-questionnaire-extr-obsn.html">SDC Questionnaire Extract - Observation</a></td>
      </tr>
      <tr>
        <th>Relevant Extensions:</th>
        <td>
          <ul>
            <li><a href="StructureDefinition-sdc-questionnaire-observationExtract.html">sdc-questionnaire-observationExtract</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-observationExtractEntry.html">sdc-questionnaire-observationExtractEntry</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-observation-extract-category.html">sdc-questionnaire-observation-extract-category</a></li>
            <li><a href="{{site.data.fhir.ver.ext}}/StructureDefinition-questionnaire-unit.html">questionnaire-unit</a></li>
          </ul>
        </td>
      </tr>
      <tr>
        <th>Example Questionnaires:</th>
        <td><a href="Questionnaire-questionnaire-sdc-profile-example-cqf-PHQ9.html">example-cqf-PHQ9</a></td>
      </tr>
    </tbody>
  </table>
  <p>
    This is the simplest of the extraction mechanisms.  It leverages the same data elements as are used for the <a href="populate.html#obs-pop">
    Observation-based population</a> mechanism.  It takes advantage of the fact that most questions in the healthcare space typically
    correspond to the <code>value</code> element of an Observation.  It also takes advantage of the <code>Questionnaire.item.code</code> element that
    identifies what a concept each question or group corresponds to.<br/>
     Observation-based extraction can now also support cross-resource references 
    (e.g., enabling a ServiceRequest to refer to an extracted Observation) by using the <code>observationExtractEntry</code> extension. 
    This allows specifying metadata like fullUrl, resourceId, ifNoneExist, etc. that enable other resources to reference the extracted Observation. 
    See <a href="#supporting-cross-resource-referencing">Supporting Cross-Resource Referencing</a> for details. .
  </p>
  <p>
    To use this method:
  </p>
  <ol>
    <li>Include the <code>item.code</code> element on each question to be extracted.  Typically, this will be a LOINC code, but in some
      jurisdictions/environments, SNOMED CT or other codes may be relevant.</li>
    <li>Groups can also have an <code>item.code</code> present - this might represent the code of the panel or the Observation.code of an Observation with no
      value but with multiple <code>Observation.component</code> elements.  Child question items can then assert the <code>item.code</code> of the "member-of"
      Observations or the <code>Observation.component.code</code> values.</li>
    <li>To signal that the item.code is intended for use in extraction (as opposed to just providing metadata about the Questionnaire item), the
      <code>observationExtract</code> extension must also be included (and set to true).  
      This extension can be specified either at the root Questionnaire or on an individual question or group item (not a display item) that indicates that the 
      observation-based approach should be used to extract either that particular item (based on the code present) or all items in the questionnaire (if they have a code present).</li>
    <li>    
      <p>
        The extension can also be applied to specific item.code elements to control which codes should be propagated during extraction. For example, an item might list codes for 
        "Body weight", "Body weight (clothed)" and "Body weight (unclothed)". If only the "Body weight" code should be included in the extracted content, the extension should be set 
        to 'true' only on that specific code element. When any item.code elements are tagged with 'true', only the tagged codes will propagate - sibling codes with no extension are 
        considered to have an implicit extension value of 'false'. If no extension appears on any of the <code>item.code</code> elements but an extension appears on the item itself, 
        an ancestor item, or the Questionnaire root, then all codes are considered equivalent and appropriate to include as sibling codings within <code>Observation.code</code>.
      </p>
      <p>
        The observation-extract extension is inherited.  If an item or code doesn't declare a value for the extension, the element is treated as though it declared the same value as 
        its nearest ancestor that has the extension.  Note that codes have no descendants, so extensions on a code will not propagate.
      </p>
	  </li>
    <li>
  Optionally, use the 
  <code>observationExtractEntry</code> extension on a <code>Questionnaire.item</code> to define metadata such as 
  <code>fullUrl</code>, <code>resourceId</code>, or conditional  fields (<code>ifNoneExist</code>, <code>ifMatch</code>, etc.) for the extracted <code>Observation</code>. This enables other extracted resources (e.g., 
  <code>ServiceRequest.supportingInfo</code>) to reference the Observation within the same transaction Bundle. See 
  <a href="#supporting-cross-resource-referencing">Supporting Cross-Resource Referencing</a> for more details.
</li>
  </ol>
  <p>
    <b>Category assignment:</b> The <code>observation-extract-category</code> extension only applies when extraction has been determined to occur. The category value on an item or code will 
    override any category declared on ancestor elements. If multiple categories are needed, all must be declared on the specific item.
  </p>
  <p>
    When performing the extraction process, the system will create a batch that will contain creates or updates of Observation instances.  It will go through
    the QuestionnaireResponse and identify all answers marked for extraction (if the corresponding Questionnaire item or the root Questionnaire has a
    <code>observationExtract</code> extension).  For each of those it will then
    determine whether to create a new observation, update an existing observation or do nothing.  Guidelines for making this decision are as follows:
  </p>
  <table class="grid">
    <tbody>
      <tr>
		<th>Take no action if:</th>
        <td>
          <ul>
            <li>the answer was populated from an existing Observation;</li>
            <li>the system rendering the QuestionnaireResponse can retain context and knows the 'id' of Observation to update;</li>
            <li>the author of the original Observation is the same as the current author of the QuestionnaireResponse;</li>
            <li>the context of the questionnaire and the use of it is one where updates are appropriate - as opposed to asserting a new Observation with a new
              performer and date; and</li>
			<li>the answer has <b>not</b> changed from the populated value;</li>
          </ul>
        </td>
	  </tr>
      <tr>
        <th>Update if:</th>
        <td>
          <ul>
            <li>all of the conditions above apply with the exception that the value <b>has</b> changed.</li>
          </ul>
        </td>
      </tr>
      <tr>
        <th>Create a new Observation if:</th>
        <td>the conditions in the preceding two rows are not met</td>
      </tr>
    </tbody>
  </table>
  <p>
    If updating, the original Observation <code>SHALL</code> be adjusted to have the new value or component.value and the status changed to "amended", then PUT to 
    the source system.  If creating, data elements SHOULD be populated as follows:
  </p>
  <ul>
    <li>
      <code>Observation.basedOn</code> and <code>Observation.partOf</code> - copy from QuestionnaireResponse elements of the same name</li>
    <li>
      <code>Observation.status</code> - set to 'final'</li>
    <li>
      <code>Observation.category</code> - if this can be inferred from any of the <code>Questionnaire.item.code</code> values or from known context of the
      Questionnaire itself, then fill it in.  It can also be asserted using the 
      <code>observation-extract-category</code> extension.</li>
    <li>
      <code>Observation.code</code> - add all the <code>Questionnaire.item.code</code> values as <code>Observation.code.coding</code> instances</li>
    <li>
      <code>Observation.subject</code> - set to <code>QuestionnaireResponse.subject</code>
    </li>
    <li>
      <code>Observation.encounter</code> - set to <code>QuestionnaireResponse.encounter</code> (if an Encounter)</li>
    <li>
      <code>Observation.effectiveDateTime</code> - set to <code>QuestionnaireResponse.authored</code>.<br/>
      <br/>Note, this is an inference.  It is important that the question text implies that the value is 'current' not 'historical' for this to be safe -
      otherwise do not include the <code>observationExtract</code> extension 
	  that marks the question as appropriate for extraction.</li>
    <li>
      <code>Observation.issued</code> - set to <code>QuestionnaireResponse.authored</code>
    </li>
    <li>
      <code>Observation.performer</code> - set to <code>QuestionnaireResponse.author</code>
    </li>
    <li>
      <code>Observation.value[x]</code> - set to <code>QuestionnaireResponse.item.answer.value[x]</code>
    </li>
    <li>
      <code>Observation.derivedFrom</code> - set to a reference to the QuestionnaireResponse</li>
    <li>
      <code>Observation.interpretation</code> and <code>Observation.referenceRange</code> - if these can be inferred from the <code>
      QuestionnaireResponse.item.code</code> (and for interpretation the answer value too), they can be populated, otherwise omit</li>
  </ul>
  <p>
    If the <code>Questionnaire.item</code> that is linked to an Observation contains child items that are also linked to Observations, then things get more complex as a
    determination will need to be made on whether to link the parent to child as <code>Observation.component</code> or as <code>Observation.hasMember</code>.
    The appropriate relationship to use is conveyed using the code value found in the <code>observationExtract</code> 
    extension.  If no extension is present or the value is only a boolean, the expected relationship is undefined and behavior is up to the extracting system.
  <!-- TODO: Should we have an extension that covers this? -->
  </p>
  <p>
    Considerations and rules when using this approach:
  </p>
  <ul>
    <li>
      If a questionnaire item has the <code>questionnaire-unit</code> extension, the
      <code>Observation.value</code> SHOULD be a valueQuantity rather than integer or decimal and the units should be taken from the extension value.</li>
    <li>
      If a question is skipped (no answer) or cleared, no Observation should be created.  Existing Observations <code>SHALL NOT</code> be deleted.</li>
    <li>
      If a question has multiple answers, each answer <code>SHALL</code> be a separate Observation instance.</li>
    <li>
      There is no mechanism to support items that are mapped to Observation codes which then have nested items without codes - e.g. to capture the text
      description for an "other - please specify" code - one of the other extraction mechanisms will need to be used.</li>
    <li>
      Implementers are free to try combining this mechanism with the <a href="#definition-extract">Definition-based</a> approach.  If they do, they should take
      care that a given item (and its children) are only handled by one approach or the other - not both.</li>
    <li>
      This approach does not allow for observations where <code>Observation.focus</code> is relevant or for capturing <code>Observation.dataAbsentReason.</code>
    </li>
    <li>Where an Observation is known to directly correlate to another resource element value (e.g. LOINC 21112-8 corresponds to
      <code>Patient.birthDate</code>), systems MAY take advantage of this knowledge to update the value of resources other than Observations, however such use
      is discouraged - using one of the other extraction techniques is likely better and safer.</li>
    <li>Obviously, this mechanism only works for questionnaire items that correspond to Observation values.</li>
  </ul>

<a name="supporting-cross-resource-referencing"> </a>
<h5>Supporting Cross-Resource Referencing</h5>
<p>
To enable extracted Observations to be referenced by other resources (e.g., a <code>ServiceRequest.supportingInfo</code>), a new extension 
<code>ObservationExtractEntry</code> is introduced. This extension may be used on <code>Questionnaire.item</code> to 
predefine bundle-related metadata for the extracted <code>Observation</code>, such as its <code>fullUrl</code> or <code>resourceId</code>.
</p>
<p>
The extension supports the following elements:
</p>
<ul>
  <li><b>fullUrl</b> – A unique full URL for the Observation within the Bundle</li>
  <li><b>resourceId</b> – A specific resource ID to assign to the Observation</li>
  <li><b>ifNoneMatch</b>, <b>ifModifiedSince</b>, <b>ifMatch</b>, and <b>ifNoneExist</b> </li>
</ul>

  <a name="definition-extract"> </a>
  <h4>Definition-based extraction</h4>
  <table class="grid">
    <tbody>
      <tr>
        <th>Profile:</th>
        <td><a href="StructureDefinition-sdc-questionnaire-extr-defn.html">SDC Questionnaire Extract - Definition</a></td>
      </tr>
      <tr>
        <th>Relevant Extensions:</th>
        <td>
          <ul>
            <li><a href="StructureDefinition-sdc-questionnaire-definitionExtract.html">sdc-questionnaire-definitionExtract</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-definitionExtractValue.html">sdc-questionnaire-definitionExtractValue</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-extractAllocateId.html">sdc-questionnaire-extractAllocateId</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-itemExtractionContext.html">questionnaire-itemExtractionContext</a> (deprecated)</li>
            <li><a href="{{site.data.fhir.ver.ext}}/StructureDefinition-questionnaire-hidden.html">questionnaire-hidden</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-initialExpression.html">sdc-questionnaire-initialExpression</a></li>
            <li><a href="{{site.data.fhir.ver.ext}}/StructureDefinition-variable.html">variable</a></li>
            <li><a href="StructureDefinition-sdc-questionnaire-launchContext.html">sdc-questionnaire-launchContext</a></li>
          </ul>
        </td>
      </tr>
      <tr>
        <th>Example Questionnaires:</th>
        <td>
          <ul>
            <li><a href="Questionnaire-demographics.html">Demographics</a></li>
            <li><a href="Questionnaire-extract-complex-defn3.html">Complex Definition Extract</a></li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    This approach to extraction is more generic than the observation-based extraction. It supports extracting data into any type of FHIR resource rather than being limited to only Observation.
    It also supports extracting additional Observation properties not defined for the observation-based extract, e.g. explicit effective time ranges, interpretations, comments, etc.<br/>
    The technique is called "definition-based" because it uses StructureDefinitions to identify resource types/profiles, and their properties which are then associated with items in the Questionnaire
    using the <code>Questionnaire.item.definition</code> element.<br/>
  </p>
  <p>
    The basic approach to the definition-based extraction mechanism is to walk the QuestionnaireResponse and for each item that has the 
    <code>definitionExtract</code> extension, create a new stub resource of that type/profile,
    then scan the item and all its children and populate values in the resource based on items that have a matching <code>definition</code> property set, or
    have <code>definitionExtractValue</code> extensions on them
    that have the same definition canonical URL value as in the <code>definitionExtract</code> extension. Once all the children have been processed,
    the system will populate the <code>bundle.entry.resource</code> property with the extracted resource, and the <code>bundle.entry.request.method</code> and
    other properties with values based on the <code>definitionExtract</code> extension. If the definition was to a profile, any slicing information or 
    fixed/pattern values should also be extracted from the profile and applied to the resource where appropriate.
    For example an identifier might have a fixed system property defined in a profile slice.
  </p>
  <p>
    The item's <code>definition</code> property is composed of:
  </p>
    <ul>
      <li>
        The full canonical URL of the resource or profile.<br/>
      e.g. <code>http://hl7.org/fhir/StructureDefinition/Patient</code> or <code>http://example.org/fhir/StructureDefinition/LocalizedPatientProfile|2.1.1</code>
      </li>
      <li>Followed by a <code>#</code> symbol.</li>
      <li>
        Then the <code>snapshot.element.id</code> of the element in the StructureDefinition that corresponds to the Questionnaire item.<br/>
        e.g. <code>Patient.name.given</code>
      </li>
    </ul>
  <p>
    Putting this all together, a definition property looks like this: <code>http://hl7.org/fhir/StructureDefinition/Patient#Patient.name.given</code>.
  </p>
  <p>
  If the Questionnaire author needs to indicate a specific version of a StructureDefinition or profile to use for extraction, they can append a pipe-delimited version before the hash fragment.
  For example: <code>http://example.org/fhir/StructureDefinition/LocalizedPatientProfile|2.1.1#Patient.name.given</code> will indicate that the extraction logic should reference version 2.1.1 of the profile when resolving the element path.
  </p>

  <blockquote>
  <p>
    <b>Note:</b> The complete element id does not actually need to appear in a profile snapshot, it is also possible to 'extend' an id to walk further into the data types of the specified element.<br/>
    For example, the example above <code>http://hl7.org/fhir/StructureDefinition/Patient#Patient.name.given</code> is valid, even though the referenced profile's snapshot only contains <code>Patient.name</code>,
    not <code>Patient.name.given</code>.<br/>
    However, for more complex references (e.g. referring to a particular extension or a particular repetition), it will be necessary to define a 
    distinct profile where slicing ensures that a single element id corresponds to the desired element.  I.e. you would need to use 
    <code>http://example.org/fhir/StructureDefinition/LocalizedPatientProfile|2.1.1#Patient.name.given:foo</code> where 'foo' was a slice that referred to the first middle name in order to tie to a definition that specific.<br/>
    </p>
  </blockquote>

  <p>
    To use this method:
  </p>
  <ol>
    <li>
      Traverse the QuestionnaireResponse from its root through each item iteratively, based on the structure in the Questionnaire.
    </li>
    <li>
      <b>Allocate fullUrl uuid variables (if needed):</b> If an extracted resource needs to reference a resource that is created within the transaction bundle it requires a known <code>entry.fulUrl</code> value (as a new uuid value for each resource instance).
      The <code>extractAllocateId</code> extension can be used to allocate
      a named new uuid for this purpose. It should be defined on the item (or root) such that its children cover the resource that is to be created, and also
      the resources that are to reference it.
      This variable name can then be used in the definitionExtract extensions's <code>fullUrl</code> FHIRPath expression, and also in any reference properties
      - typically using the <code>definitionExtractValue</code> extension (further described below).
      <ul>
        <li>This string value is not a FHIRPath expression to be evaluated, it is the name for the variable that will be available to FHIRPath expressions.</li>
        <li>The allocateId extension will be made available to all FHIRPath expressions on that node, and any child items.</li>
        <li>Use the variable name in the allocateId to set the <code>entry.fullUrl</code> of the resource you want to reference in the definitionExtract extension's fullUrl property.</li>
        <li>Use the variable name to set the reference property using the definitionExtractValue extension's expression property.</li>
        <li>If this allocateId extension is defined at the root of the questionnaire, a single value will be allocated for the entire extracted transaction bundle.</li>
        <li>If this allocateId extension is defined on a repeating group, a new value will be allocated for each repetition of the item.</li>
        <li>It is recommended to use meaningful names in the allocateId extension value, e.g. <code>%newPatientUuid</code> or <code>%newEncounterUuid</code></li>
      </ul>
      If the extracted resource being referenced repeats (multiple instances could be extracted), then the extract rules for the resources that reference that repeating item must also be within the same repeating group item in order
      for them to use the same allocated id.
    </li>
    <li>
      <b>Initiate Resource extraction:</b> Include the <code>definitionExtract</code> extension on either the Questionnaire root or on
      other items within the Questionnaire to mark the point at which a new resource will be extracted (and what resource type/profile if applicable).<br/>
      This is a complex extension that includes the following properties: <code>definition</code> (resource/profile canonical URL),
      and optionally fullUrl, ifNoneMatch, ifModifiedSince, ifMatch and ifNoneExist (FHIRPath expression expressions used to populate the transaction bundle entry containing the extracted resource).
      <ul>
        <li>
          If the extension is at the root of the Questionnaire, the resource will always be extracted, even if there are no answer items within the fully completed QuestionnaireResponse.
        </li>
        <li>
          If the extension is on a specific item, the resource will only be extracted if there are answers to that item in the QuestionnaireResponse.
          (For items that repeat, a new instance of the resource will be created for each repetition).
        </li>
        <li>
          If the resource is created by a profile definition rather than a core resource type profile, the profile name will be added to the meta of the extracted resource.
        </li>
        <li>
          Once the resource is completely extracted, the system <code>SHALL</code> populate the <code>bundle.entry.resource</code> property with the extracted resource, then populate the other
          <code>bundle.entry</code> properties:
          <ul>
            <li>
              <code>fullUrl</code> - the result of the FHIRPath expression for the <code>fullUrl</code> property, if none is provided, a new uuid will be allocated for the resource.
              (this will often be an expression that uses the named variable from the <code>allocateId</code> extension e.g. <code>%newPatientUuid</code>)
            </li>
            <li>
              <code>request.method</code> - if the resource has no <code>id</code> property set the value to <code>POST</code> (requesting a create),
              otherwise set the value to <code>PUT</code> (requesting an update).<br/>
              <i>The <code>resource.id</code> could be set using a hidden item (pre-populated during data-entry), or using the <code>definitionExtractValue</code> extension.</i>
            </li>
            <li>
              <code>request.url</code> - if the resource is being updated  the url will be the resource type and the <code>id</code> property of the resource. e.g. <code>Patient/123</code>,
              otherwise it will be the resource type. e.g. <code>Patient</code>.
            </li>
            <li>
              <code>request.ifNoneMatch</code> - the result of the FHIRPath expression for the <code>ifNoneMatch</code> property
            </li>
            <li>
              <code>request.ifModifiedSince</code> - the result of the FHIRPath expression for the <code>ifModifiedSince</code> property (evaluates to a date time value - or nothing)
            </li>
            <li>
              <code>request.ifMatch</code> - the result of the FHIRPath expression for the <code>ifMatch</code> property
        </li>
        <li>
              <code>request.ifNoneExist</code> - the result of the FHIRPath expression for the <code>ifNoneExist</code> property
            </li>
          </ul>
        </li>
        <li>
          There can be multiple of these extensions interleaved on separate items, and also on the same item. However the <code>definition</code> property in the extension
          <code>SHALL</code> be unique in the scope that they are introduced in the questionnaire.
          i.e. You can't define two <code>http://hl7.org/fhir/StructureDefinition/Condition</code> extractions on the same item (or any of its children), but you can have
          multiple on sibling items do this.<br/>
          You could however have different profiles of the same resource overlapping. This is due to the <code>definition</code> property being the "scoper"
          to identify the resource/property to extract the item answer into.
        </li>
      </ul>
      <blockquote>
        <p>
          <i>
            <b>Note:</b> In previous versions of the SDC specification the <code>itemExtractionContext</code> extension 
            was used to indicate the resource type, however this has been deprecated and we encourage moving to the newer <code>definitionExtract</code> extension.
          </i>
        </p>
      </blockquote>
    </li>
    <li>
      <b>Indicate properties to populate in extracted resource:</b> For the item and any descendant items of an item (or root) with the <code>definitionExtractValue</code> extension:
      <ul>
        <li>
          Set the <code>Questionnaire.item.definition</code> to associate an answer to the item with a property in the extracted resource.<br/>
          Note that the canonical URL to the profile in the definition MUST match the canonical URL in the definitionExtract extension (or the canonical URL of the resource type in the deprecated itemExtractionContext).<br/>
          (when interleaving profiles, the definitionExtract extension is the "scoper" for the property to extract the answer into).
        </li>
        <li>
          In cases where you need to make a group item match up with a collection, or backbone element in the StructureDefinition, just use that element to connect them.<br/>
          e.g. Use the definition: <code>http://hl7.org/fhir/StructureDefinition/Patient#Patient.name</code> on a group item to collect the child items to the same Patient.name element.
          During extraction, the system will create a new patient name element for each repetition of the group item, and then populate each name with the child items.<br/>
          With this example, the nested child items would have definitions like <code>http://hl7.org/fhir/StructureDefinition/Patient#Patient.name.given</code> and <code>http://hl7.org/fhir/StructureDefinition/Patient#Patient.name.family</code>.
        </li>
        <li>
          Items are not required in the questionnaire for every element level in the StructureDefinition. The system will create the necessary elements as needed.<br/>
          e.g. You could have a single item that captures <code>Patient.contact.name.text</code> and the system will create the necessary Patient.contact and Patient.contact.name elements
          to then set the text values in. In this case if the item was repeating, the last node in the iteration is the one that will be repeated (name in this case).<br/>
          If you intend to have a specific level of the element repeated, you should have a group item that repeats, and then have the item that corresponds to the element within that group.<br/>
          This technique is particularly useful when populating properties in CodeableConcepts, where you can drill directly into the Coding, or text property, and don't require another level
          in your questionnaire just to add that in.
        </li>
        <li>
          Add <code>definitionExtractValue</code> extension(s) to the root/item to specify calculated or fixed values
          to populate into the resource when an answer for this item is entered (or always when at the root of questionnaire).<br/>
          This is particularly useful for populating fixed values, or calculated values that are not directly entered by the user.<br/>
          e.g. To assign the value from the <code>QuestionnaireResponse.subject</code> property into a property in the extracted resource.<br/>
          If <code>definitionExtractValue</code> is used on an item that also has its <code>item.definition</code> property set, that would be assumed to be extracted resource context. 
          Hence you could set the system and type values in an
          identifier when associated with that item.
        </li>
        <li>
          If a profile is used in the definition, any fixed values or patterns in the profile will be included in the extracted resource.
          These MAY be processed when stepping through sliced properties in the profile.<br/>
          e.g. To set other properties in an identifier property that is associated with a specific slice, such as a fixed system and type value.
        </li>
        <li>
          Although the answer for a <code>QuestionnaireResponse.item</code> can repeat (indicated by the repeat property), the evaluation of the item will only occur once, and the multiple
          answers are processed for the one item at the same time. For FHIRPath expressions, the answer will be a list of values (for the one item) that the expression must
          handle correctly to populate the item.<br/>
          e.g. If the item was for <code>Patient.name.given</code> (which can repeat), that "set" of answers will directly map into the resource property (which is also a collection).
          However if you tried to map that into the text property, which is singular, this would be an error. A FHIRPath expression would be required to concatenate the values 
          together such as <code>answer.join(', ')</code>.<br/>
          As "group" items iterate differently to "question" items, the evaluation will process each iteration of the group separately.
        </li>
        <li>
          Some type casting will be required as not all data-types are available in questionnaire items, however these can all be mapped.
        </li>
      </ul>
    </li>
    <li>
      <b>Matching parent/child properties in the extracted resource instance:</b>
      As described above, the system will create the necessary elements in the resource as needed, but this is not always obvious what to do when it's not a direct 1..1 mapping from the questionnaire to the resource.<br/>
      So this table is here to help guide the process with examples of how to populate the resource properties based various parent/child questionnaire item configurations:
      <table class="grid">
        <thead>
          <tr>
            <th>Example Parent</th>
            <th>Parent Type</th>
            <th>Example Child Definition</th>
            <th>Possible Child Type</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>
          Patient</td><td><i>definitionExtract</i></td><td>Patient.name</td><td><i>group item</i></td><td>Create a new <code>HumanName</code> object and add it to the name collection in patient
          </td></tr>
          <tr><td>
            Patient.name</td><td><i>group item</i></td><td>Patient.name.text</td><td><i>value item</i></td><td>Set the text property in the name object
          </td></tr>
          <tr><td>
            Patient</td><td><i>definitionExtract</i></td><td>Patient.name.text</td><td><i>value item/extractValue</i></td><td>Create a new <code>HumanName</code> object, add it to the name collection in patient, and set the text property
          </td></tr>
          <tr><td>
            Patient</td><td><i>definitionExtract</i></td><td>Patient.identifier.value</td><td><i>value item/extractValue</i></td><td>Create a new <code>Identifier</code> object, add it to the identifier collection in patient, and set the value property
          </td></tr>
          <tr><td>
            Patient</td><td><i>definitionExtract</i></td><td>Patient.extension</td><td><i>group item</i></td><td>Create a new <code>Extension</code> object and add it to the extension collection in patient
          </td></tr>
          <tr><td>
            Patient.extension</td><td><i>group item</i></td><td>Patient.extension.value</td><td><i>value item</i></td><td>Set the value property in the extension object
          </td></tr>
          <tr><td>
            Patient.extension</td><td><i>group item</i></td><td>Patient.extension.url</td><td><i>value item/extractValue</i></td><td>Set the URL property in the extension object
          </td></tr>

          <tr><td>
            Patient.extension.value</td><td><i>value item</i></td><td>Patient.extension.url</td><td><i>value item/extractValue</i></td><td>Set the URL property for the same extension instance that has the value in it (walks up the tree to the common ancestor)
          </td></tr>
          <tr><td>
            Patient.identifier.value</td><td><i>value item</i></td><td>Patient.identifier.type.text</td><td><i>value item/extractValue</i></td><td>Create a new <code>CodeableConcept</code> object, add it to the type collection of the identifier object that has the value in it, and set the text property in that type object
          </td></tr>
        </tbody>
      </table>
      <blockquote>
        <p>
          <b>Note:</b> Anywhere in a resource that you need to set multiple item's values into properties of a backbone element, you will need to use a group item to collect the values together, and set the <code>definition</code> property on this group item
          to the backbone element.  The system will then create the backbone element and populate it with the child items.
        </p>
      </blockquote>
    </li>
    <li>
      <b>Handling sliced properties:</b> If extracting a property via a sliced property:
      <ul>
        <li>If there are any associated fixed or pattern values in the slice, also populate those values into the resource instance</li>
        <li>If the slice limits the types supported, ensure that the created type is supported (and cast the value if required)</li>
        <li>
          After the property is extracted, if there are any required properties that have fixed/pattern values, also extract those<br/>
          e.g. In the <a href="https://hl7.org/fhir/r4/bodyheight.html">body height profile</a>, the category slice VSCat is required, and has a required coding property with a fixed value of "vital-signs".  This would also need to be extracted.
        </li>
        <li>
          A type slice can be invoked without an actual slice for choice typed properties e.g. <code>value[x]</code><br/>
          The extraction process is able to determine the correct type to use based on the answer in the QuestionnaireResponse, or explicitly
          define it in the property name in the "definition" value e.g. <code>http://hl7.org/fhir/StructureDefinition/Observation#Observation.valueQuantity</code><br/>
          This type slicing is really only required where the type is a choice and the value being set is not directly coming from the QuestionnaireResponse item and there
          is no ambiguity on the type to use. E.g. assigning an item to <code>Patient.extension.value.code</code> could be a Quantity or a Coding, thus needs to be disambiguated.
          <code>Patient.extension.valueCoding.code</code> or <code>Patient.extension.valueQuantity.value</code> would be the appropriate definitions to use.
          However if I was using the definition <code>Patient.extension.value</code> and the item was of type boolean or Coding, there is no need to type slice, 
          as the value is of the correct type to just assign (it doesn't need to create the intermediate valueQuantity or valueCoding before trying to set the actual value from the item).
        </li>
      </ul>
      <i>(These could also be considered at the root level when processing a profiled resource)</i>
    </li>
    <li>
      <b>Supporting the extraction process:</b> If necessary, define items with the <code>hidden</code> extension 
      that have <code>Questionnaire.item.initial.value[x]</code> or that use the
      <code>questionnaire-initialExpression</code> extension to define their content to use to populate
      resource elements that the user will not be filling in.  (The initialExpressions might in turn depend on
      <code>variable</code> and
      <code>questionnaire-launchContext</code> extensions, used as described in the
      <a href="populate.html#exp-pop">Expression-based population</a>
      section, however that evaluation is all outside the scope of the $extract operation, and those variables are not available to $extract processing.<br/>
      This is particularly useful for retaining the resource ID of a resource that is extracted to use to update the resource (method = PUT).
    </li>
  </ol>
  <blockquote>
    <p>
      <b>Note:</b> The extraction processes as defined does not support "merging" the answers into an existing instance of a resource as an update. 
      Instead the "update" mode of this extraction process is a "replace" style process. So if you need to update content that was not created by the 
      extraction routine, you will need to inject ALL data from the resource into the questionnaire (and hide properties as needed).
      This way all the data will be available to fill out into the resource so that it can be included as an update in the outgoing transaction bundle.
      This design was used as the target server for the bundle isn't necessarily going to be the same server that was pre-populated from.
    </p>
  </blockquote>
  <p>
    Other considerations and rules when using this approach:
  </p>
  <ul>
    <li>
      FHIRPath expressions used in the $extract approach do not have access to the <code>launchContext</code>, <code>initialExpression</code>, or <code>variable</code> extensions.  They are only able to
      access the QuestionnaireResponse data and the Questionnaire data and specific extract only extensions (extractAllocateId). Refer to the 
      <a href="expressions.html#extract">expressions</a> page for more details.
    </li>
    <li>
      If the result of evaluating the FHIRPath expressions is an invalid query, that is an error.  Systems SHOULD log it and continue with extraction as if
      the query had returned no data. The error can be returned in the operation outcome alongside the transaction bundle.
    </li>
    <li>
      While validating a Questionnaire resource that uses the definition-based extraction mechanism, the system <code>SHALL</code> validate that the <code>definition</code> property
      matches up with the StructureDefinition that is being referenced.  It can also warn if there is no definitionExtract that would initiate the extraction process for
      the resource/profile.
    </li>
    <li>
      The items in the Questionnaire might not have the same order as those in the resource.  When serializing into XML, the official order must still be
      respected.</li>
  </ul>

  <a name="template-extract"> </a>
  <h4>Template-based extraction</h4>
  <table class="grid">
    <tbody>
      <tr>
        <th>Profile:</th>
        <td></td>
      </tr>
      <tr>
        <th>Relevant Extensions:</th>
        <td>
          <ul>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </td>
      </tr>
      <tr>
        <th>Example Questionnaires:</th>
        <td></td>
      </tr>
    </tbody>
  </table>
  <p>
    The template based approach provides an alternative to the definition based approach and where the full power of StructureMaps isn't required.
    It supports the same level of capability, however is unable to leverage any of the information inside a profile where the definition based approach can.<br/>
    The <a href="StructureDefinition-sdc-questionnaire-extr-template.html">SDC Questionnaire Extract - Template</a> profile has been created to support this mechanism. 
  </p>
  <p>
    This technique is called "template-based" because it uses a template resource(s) to provide all the "boiler-plate" content for the resource that is to be extracted.
    These templated resources are contained within the Questionnaire resource and referred to by either the <a href="StructureDefinition-sdc-questionnaire-templateExtract.html">sdc-questionnaire-templateExtract</a>
    or <a href="StructureDefinition-sdc-questionnaire-templateExtractBundle.html">sdc-questionnaire-templateExtractBundle</a> extensions.
  </p>
  <p>
    The template is annotated with expressions to indicate which parts of the template should be populated with data from the QuestionnaireResponse, and which 
    parts should be removed if no data is present. The expressions are defined using the FHIRPath language, and the QuestionnaireResponse context of the expressions is based on the location
    of the template reference in the questionnaire, and/or any inline context expressions defined in the template.
  </p>
  <p>
    The difference between the <a href="StructureDefinition-sdc-questionnaire-templateExtract.html">templateExtract (resource)</a> and <a href="StructureDefinition-sdc-questionnaire-templateExtractBundle.html">templateExtractBundle</a> extensions is that the template resource extension will extract each resource individually
    as a separate bundle entry and includes expressions to populate the other bundle entry properties,
    whereas the template bundle extension extract the transaction bundle as a single resource. The processing of the template is otherwise identical between the two extensions.
  </p>
  <p>
    To use this method:
  </p>
  <ol>
    <li>
      Include the <a href="StructureDefinition-sdc-questionnaire-templateExtract.html">sdc-questionnaire-templateExtract</a> extension at the root or the questionnaire,
      and/or any items in the questionnaire that indicate a resource should be created for each answer in a questionnaire response for that item.<br/>
      This extension includes a relative reference to the resource template which <code>SHALL</code> be contained within the same Questionnaire resource, and will be extracted into a new entry in the output transaction bundle (with other values processed from the complex extension).<br/>
      Alternately use the <a href="StructureDefinition-sdc-questionnaire-templateExtractBundle.html">sdc-questionnaire-templateExtractBundle</a> extension at the root
      to use a template bundle. This is the same as the templateExtract extension but leverages a single bundle that has all templated resources in it.
    </li>
    <li>
      Include any required template resources as contained resources in the questionnaire and refer to them using either the <a href="StructureDefinition-sdc-questionnaire-templateExtract.html">sdc-questionnaire-templateExtract</a> 
      or <a href="StructureDefinition-sdc-questionnaire-templateExtractBundle.html">sdc-questionnaire-templateExtractBundle</a> extension as described above.
    </li>
    <li>
      If you need to dynamically reference between resources created in the output transaction bundle (using the entry.fullUrl property), include the allocateId extension
      at a point in the questionnaire that defines the scope that a new uuid is required for each iteration of the item.
      If at the root, a new value will be allocated only once, if on an item, it will be allocated for each related item that has the extension (a new value per item in a collection).
      The value is only available to child items of the item that has the extension (or itself).<br/>
      This value can be used in the templateExtract extension to set the fullUrl property of the extracted resource, and in the templateExtractValue extension to set the value for the referencing property.<br/>
      The allocateId extension is not a FHIRPath expression to be evaluated, it is the name for the variable that will be available to FHIRPath expressions, and it's value will be
      a new uuid for each iteration of the item that has the extension, before any expressions in the templateExtract, templateExtractBundle or templateExtractValue are evaluated.
    </li>
    <li>
      During extraction a new resource will be created for each answer in the QuestionnaireResponse for the item that contains the templateExtract extension.<br/>
      The <code>resource.id</code> of the new resource will be removed (as it currently has the resource id to refer to in the template from the questionnaire definition).
      To set the <code>resource.id</code> property use the <code>resourceId</code> property in the <code>templateExtract</code> extension (this is not possible using the templateExtractBundle based extraction).
    </li>
    <li>
      The FHIRPath context of the extracted resource will be based on the location of the templateExtract extension in the questionnaire.<br/>
      If templateExtract is on the root of the questionnaire, the FHIRPath context will be the QuestionnaireResponse resource.<br/>
      If templateExtract is on an item, the FHIRPath context will be the item in the QuestionnaireResponse associated with that item's linkId.<br/>
    </li>
    <li>
      The extraction engine <code>SHALL</code> scan the templated resource for any <a href="StructureDefinition-sdc-questionnaire-templateExtractContext.html">sdc-questionnaire-templateExtractContext</a> 
      or <a href="StructureDefinition-sdc-questionnaire-templateExtractValue.html">sdc-questionnaire-templateExtractValue</a> extensions (in that order) and then:
      <ul>
        <li>
          Evaluate the FHIRPath expression defined in the extension <i>(only FHIRPath is supported)</i>.
        </li>
        <li>
          If the expression returns no results, this templated property (context or value) will be removed from the extracted resource, and no further processing of that property will occur.<br/>
          If the template property is a in a collection, simply remove the templated value from the collection, don't clear the entire collection. There MAY be other
          templated properties to process in the collection (or static template data).
        </li>
        <li>
          For every result returned by the expression, a new copy of the templated property will be cloned and scanning the child properties will continue.
        </li>
        <li>
          If the context expression is defined as an <code>Expression</code> datatype, and it has a name property, then that variable will be made available to any child property extraction expressions.
        </li>
        <li>
          Any context results will change the context to use for processing any child properties (and templateExtractValues on the same node).
        </li>
        <li>
          Any extractValue results will be used to replace the property value in the extracted resource.<br/>
          Note that for primitive properties in json the <code>_value</code> and <code>value</code> represent the same FHIR property and must be considered the same property.
          So ensure that the extract extension is removed from <code>_value</code>, the <code>value</code> is set (and any other extensions can remain).<br/>
          This is important as some properties such as reference properties are required to have a valid <code>value</code> and not just an extension so they will have a value that is expected to be either removed (when no data) or replaced (when data is present).
        </li>
      </ul>
    </li>
    <li>
      When using the templateExtract extension (not the templateExtractBundle extension), the extraction engine <code>SHALL</code> create a transaction Bundle containing all the resources that were extracted from the QuestionnaireResponse.
      Each resource that is extracted will be added into the transaction bundle that is returned by the $extract operation.<br/>
      The fullUrl, resourceID and <code>entry.request</code> properties <code>SHALL</code> be updated with values calculated from the
      templateExtract complex extension.<br/>
      If a resource has it's ID populated, then it will be treated as an update to the existing resource (<code>entry.request.method='PUT'</code>), otherwise it will be treated as a create (<code>entry.request.method='POST'</code>).
    </li>
  </ol>

  <p>
    If FHIRPath expressions produce errors/exceptions or invalid/incompatible value types, the 
    extraction engine <code>SHALL</code> log the error and continue processing the next property.
    If there were any fatal or error level issues, the extraction engine <code>SHALL</code> return an OperationOutcome with the issues.<br/>
    If there are only warning/information issues, they can be returned along with the transaction bundle.
  </p>
  <p>
    Template based extraction using the templateExtractBundle extension is incompatible with modular forms.<br/>
    If using the templateExtract extension with modular forms, the assembly will merge all the contained resources 
    from the module into the output Questionnaire, and may need to rename the contained reference ids if collisions
    are to occur.
  </p>
  <blockquote>
    <p>
      <b>Note:</b> Many templating engines have constructs like conditionals and loops. Although not immediately obvious, these can be implemented using this template approach.
      Conditional properties are implemented with the FHIRPath expression in the <a href="StructureDefinition-sdc-questionnaire-templateExtractContext.html">templateExtractContext</a>
      or <a href="StructureDefinition-sdc-questionnaire-templateExtractValue.html">templateExtractValue</a> extension returning no results, and thus excluding the property, backbone element or
      entry in a collection from the extracted resource.<br/>
      Loops are similar in nature where the looping is provided based on the FHIRPath expression returning multiple results, and thus creating multiple entries in an array,
      or even multiple resources in the transaction bundle driven by either multiple items in the questionnaire, or contexts in the bundle template.<br/>
      There are several examples of both of these in the template examples <a href="Questionnaire-extract-complex-template.html">here</a> and 
      <a href="Questionnaire-extract-complex-template2.html">here</a>, such as how they create multiple names in the patient resource from multiple items in the
      questionnaire name item group, or where there is no IHI identifier added if the relevant item hasn't been answered in the questionnaire.
    </p>
  </blockquote>

  <a name="map-extract"> </a>
  <h4>StructureMap-based extraction</h4>
  <table class="grid">
    <tbody>
      <tr>
        <th>Profile:</th>
        <td></td>
      </tr>
      <tr>
        <th>Relevant Extensions:</th>
        <td>
          <ul>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </td>
      </tr>
      <tr>
        <th>Example Questionnaires:</th>
        <td></td>
      </tr>
    </tbody>
  </table>
  <p>
    The <a href="{{site.data.fhir.path}}structuremap.html">StructureMap</a> approach is the most sophisticated approach of the four - and the most powerful.
    It allows significant transformation of data, including code translations when generating output resources.  It also allows the conversion process
    between data and Questionnaire to be maintained independently and to draw on shared sources across Questionnaires.  This can be an advantage in
    certain environments where the content of the questionnaire may need tight control, but the data environment can be more dynamic.  This comes at the cost
    of requiring expertise in the <a href="{{site.data.fhir.path}}mapping-language.html">FHIR mapping language</a>, which is not (yet?) a common skill.<br/>
    The <a href="StructureDefinition-sdc-questionnaire-extr-smap.html">SDC Questionnaire Extract - StructureMap</a> profile has been created to support this mechanism. An example for this profile can be found <a href="Questionnaire-SDOHCC-QuestionnaireHungerVitalSign.html">here</a>.
  </p>
  <p>
    To use this method:
  </p>
  <ol>
    <li>Include the <a href="StructureDefinition-sdc-questionnaire-targetStructureMap.html">questionnaire-targetStructureMap</a> extension.  This <code>SHALL</code> define a
      transform between the QuestionnaireResponse and either a single resource or a transaction Bundle containing the set of resources extracted from the
      QuestionnaireResponse.</li>
  </ol>
  <p>
    To extract data from the completed QuestionnaireResponse, simply invoke the StructureMap on it.  A sample Questionnaire and associated StructureMap that shows this approach can be found <a href="Questionnaire-SDOHCC-QuestionnaireHungerVitalSign.html">here</a> and <a href="StructureMap-SDOHCCHungerVitalSignMap.html">here</a>.
  </p>
  <p>
    Considerations when using this approach:
  </p>
  <ul>
    <li>This mode has the drawback that if the StructureMap execution fails, there will generally not be any data extracted from the Questionnaire. With the
      other approaches, if one Observation or context fails, the others might still work.  As a result, the StructureMap must be designed to be very robust in
      the face of missing or potentially 'bad' data.</li>
    <li>
      The ability of StructureMaps to reference other StructureMaps allows for the possibility of re-use if certain sections of multiple questionnaires are
      consistent.</li>
  </ul>
  <a name="output-expectations"> </a>
  <h4>Output expectations</h4>
    <p>
    Following are the output expectations of $extract:
  </p>
  <ul>
    <li>
      Observation-based will always produce a 'transaction' Bundle, even if it's only creating or updating a single Observation.
    </li>
    <li>
      Definition-based will always produce a 'transaction' Bundle that indicates what resources are to be created or updated.  The resources within the transaction can be anything (including Bundle resources such as FHIR documents)
    </li>
    <li>
      StructureMap-based may produce either a 'transaction' Bundle or a single resource instance (though the instance might itself be a different type of Bundle, such as a document or collection).  It is possible for StructureMaps to map to non-FHIR data structures, however there's no "built-in" mechanism to serialize such models, so additional information would need to be passed into the $extract process to guide such serialization.  Support for non-FHIR extracts is outside the scope of this specification.
    </li>
  </ul>
</div>
